/* Generated by Nimrod Compiler v0.8.8 */
/*   (c) 2009 Andreas Rumpf */
/* Compiled for: Windows, i386, gcc */
/* Command for C compiler:
   C:\Programy\nimrod\dist\mingw\bin\gcc.exe -c  -w  -IC:\Programy\nimrod\lib -o nimcache\lib\pure\strutils.o nimcache\lib\pure\strutils.c */

typedef long int NI;
typedef unsigned long int NU;
#include "nimbase.h"

typedef struct NimStringDesc NimStringDesc;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
typedef struct TGenericSeq TGenericSeq;
typedef NU8 TY108011[32];
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
};
struct TGenericSeq {
NI len;
NI space;
};
typedef NIM_CHAR TY239[100000001];
struct NimStringDesc {
  TGenericSeq Sup;
TY239 data;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
N_NOINLINE(void, raiseOverflow)(void);
N_NIMCALL(NimStringDesc*, nimIntToStr)(NI X_15003);
static N_INLINE(NI, subInt)(NI A_5403, NI B_5404);
N_NIMCALL(NimStringDesc*, rawNewString)(NI Space_14287);
static N_INLINE(void, appendChar)(NimStringDesc* Dest_14409, NIM_CHAR C_14410);
static N_INLINE(void, appendString)(NimStringDesc* Dest_14392, NimStringDesc* Src_14393);
static N_INLINE(NI, addInt)(NI A_5203, NI B_5204);
NIM_CONST TY108011 Whitespace_109003 = {
0x00, 0x3E, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
;
NIM_CONST TY108011 Letters_109005 = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0xFF, 0xFF, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
;
NIM_CONST TY108011 Digits_109007 = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
;
NIM_CONST TY108011 Identchars_109009 = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
;
NIM_CONST TY108011 Identstartchars_109011 = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
;
static N_INLINE(NI, subInt)(NI A_5403, NI B_5404) {
NI Result_5405;
NIM_BOOL LOC2;
Result_5405 = 0;
Result_5405 = (NI32)((NU32)(A_5403) - (NU32)(B_5404));
LOC2 = (0 <= (NI32)(Result_5405 ^ A_5403));
if (LOC2) goto LA3;
LOC2 = (0 <= (NI32)(Result_5405 ^ (NI32)((NU32) ~(B_5404))));
LA3: ;
if (!LOC2) goto LA4;
goto BeforeRet;
LA4: ;
raiseOverflow();
BeforeRet: ;
return Result_5405;
}
static N_INLINE(void, appendChar)(NimStringDesc* Dest_14409, NIM_CHAR C_14410) {
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "system.appendChar";
F.prev = framePtr;
F.filename = "C:\\Programy\\nimrod\\lib\\system\\sysstr.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
F.line = 153;
(*Dest_14409).data[((*Dest_14409).Sup.len)-0] = C_14410;
F.line = 154;
(*Dest_14409).data[((NI32)((*Dest_14409).Sup.len + 1))-0] = 0;
F.line = 155;
(*Dest_14409).Sup.len += 1;
framePtr = framePtr->prev;
}
static N_INLINE(void, appendString)(NimStringDesc* Dest_14392, NimStringDesc* Src_14393) {
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "system.appendString";
F.prev = framePtr;
F.filename = "C:\\Programy\\nimrod\\lib\\system\\sysstr.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
F.line = 149;
memcpy(((NCSTRING) (&(*Dest_14392).data[((*Dest_14392).Sup.len)-0])), ((NCSTRING) ((*Src_14393).data)), ((NI32) ((NI32)((NI32)((*Src_14393).Sup.len + 1) * 1))));
F.line = 150;
(*Dest_14392).Sup.len += (*Src_14393).Sup.len;
framePtr = framePtr->prev;
}
static N_INLINE(NI, addInt)(NI A_5203, NI B_5204) {
NI Result_5205;
NIM_BOOL LOC2;
Result_5205 = 0;
Result_5205 = (NI32)((NU32)(A_5203) + (NU32)(B_5204));
LOC2 = (0 <= (NI32)(Result_5205 ^ A_5203));
if (LOC2) goto LA3;
LOC2 = (0 <= (NI32)(Result_5205 ^ B_5204));
LA3: ;
if (!LOC2) goto LA4;
goto BeforeRet;
LA4: ;
raiseOverflow();
BeforeRet: ;
return Result_5205;
}
N_NIMCALL(NimStringDesc*, Inttostr_109642)(NI X_109644, NI Minchars_109645) {
NimStringDesc* Result_109839;
NI I_109851;
NI HEX3Atmp_109863;
NI Res_109865;
NimStringDesc* LOC8;
NimStringDesc* LOC15;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "strutils.intToStr";
F.prev = framePtr;
F.filename = "C:\\Programy\\nimrod\\lib\\pure\\strutils.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
Result_109839 = 0;
F.line = 412;
if (X_109644 == (-2147483647 -1)) raiseOverflow();
Result_109839 = nimIntToStr((NI32)abs(X_109644));
I_109851 = 0;
HEX3Atmp_109863 = 0;
F.line = 413;
HEX3Atmp_109863 = subInt(Minchars_109645, Result_109839->Sup.len);
Res_109865 = 0;
F.line = 1029;
Res_109865 = 1;
F.line = 1030;
while (1) {
if (!(Res_109865 <= HEX3Atmp_109863)) goto LA5;
F.line = 1029;
I_109851 = Res_109865;
F.line = 414;
LOC8 = rawNewString(Result_109839->Sup.len + 1);
appendChar(LOC8, 48);
appendString(LOC8, Result_109839);
Result_109839 = LOC8;
F.line = 1032;
Res_109865 = addInt(Res_109865, 1);
} LA5: ;
F.line = 415;
if (!(X_109644 < 0)) goto LA12;
F.line = 416;
LOC15 = rawNewString(Result_109839->Sup.len + 1);
appendChar(LOC15, 45);
appendString(LOC15, Result_109839);
Result_109839 = LOC15;
LA12: ;
framePtr = framePtr->prev;
return Result_109839;
}
N_NOINLINE(void, strutilsInit)(void) {
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "module strutils";
F.prev = framePtr;
F.filename = "C:\\Programy\\nimrod\\lib\\pure\\strutils.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
framePtr = framePtr->prev;
}

